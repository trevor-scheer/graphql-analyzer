# GraphQL LSP Project Context

## Overview

This is a GraphQL Language Server Protocol (LSP) implementation written in Rust. The project provides language server features for GraphQL files, including validation, diagnostics, and IDE integration.

## Project Structure

- `crates/graphql-config/` - Configuration parser and loader
- `crates/graphql-extract/` - Extract GraphQL from source files
- `crates/graphql-introspect/` - GraphQL introspection and SDL conversion
- `crates/graphql-linter/` - Linting engine with custom rules
- `crates/graphql-project/` - Core types, validation, and indexing
- `crates/graphql-lsp/` - Main LSP implementation
- `crates/graphql-cli/` - CLI tool for validation and linting
- `editors/vscode/` - VSCode extension for the LSP
- `tests/` - Test suites

## Key Technologies

- **Language**: Rust
- **LSP Framework**: tower-lsp
- **GraphQL Parsing**: apollo-compiler and graphql-parser
- **Build System**: Cargo

## Code Quality Standards

- Run `cargo fmt` before committing
- Run `cargo clippy` and address warnings
- Ensure `cargo test` passes
- Pre-commit hooks are set up via cargo-husky
- For VSCode extension changes:
  - Run `npm run format:check` (prettier) in `editors/vscode/`
  - Run `npm run lint` (oxlint) in `editors/vscode/`

## PR Guidelines

- Don't include notes about testing or linting passing in PR descriptions
- Don't use excessive emoji in PR titles or descriptions

## Testing

- Unit tests are located alongside source files
- Integration tests are in the `tests/` directory
- Use `cargo test` to run all tests
- Use `cargo insta` for snapshot testing (if applicable)

## Documentation

- README.md files should be kept up to date
- Before starting a new task, read the relevant README.md files for context
- Add a README.md to each crate / major directory. README.md files should:
  - Explain the purpose of the crate/directory
  - Describe how it fits into the overall project
  - Provide instructions and examples for using the code within
  - Explain technical details that would help a new contributor understand the code

## Important LSP Features

- **Goto Definition**: Comprehensive navigation support for all GraphQL language constructs
  - Fragment spreads to their definitions across files
  - Operation names to their definitions
  - Type references (in fragments, inline fragments, implements clauses, union members, field types, variable types)
  - Field references to their schema definitions
  - Variable references to their operation variable definitions
  - Field argument names to their schema argument definitions
  - Enum values to their enum value definitions
  - Directive names to their directive definitions
  - Directive argument names to their argument definitions
  - Works in both pure GraphQL files (.graphql, .gql) and embedded GraphQL in TypeScript/JavaScript
  - Handles TypeScript/JavaScript by extracting GraphQL and adjusting positions automatically
- **Find References**: Find all usages of GraphQL elements across the project
  - Fragment definitions → All fragment spreads using that fragment
  - Type definitions → All usages in field types, union members, implements clauses, input fields, arguments
  - Supports List and NonNull type wrappers
  - Respects include/exclude declaration context from client
  - Works across all open documents in the workspace
- **Hover**: Type information and descriptions for GraphQL elements
- **Diagnostics**: Project-wide validation with accurate error reporting
  - Project-wide unique name validation for operations and fragments
  - Correct line/column positioning for extracted GraphQL from TypeScript/JavaScript
  - Support for multiple GraphQL parsers (apollo-compiler and graphql-parser)

## Development Notes

- The project uses Rust toolchain specified in `rust-toolchain.toml`
- Main branch: `main`
- Follow conventional commit messages
- PRs should be created using `gh pr create`
- **IMPORTANT**: `.github/workflows/release.yml` is autogenerated by cargo-dist - do not manually edit it
  - For VSCode extension releases, edit `.github/workflows/vscode-release.yml` instead
  - To update the main release workflow, modify `Cargo.toml` dist config and run `dist init` or `dist generate`

## Common Commands

- `cargo build` - Build the project
- `cargo test` - Run tests
- `cargo clippy` - Lint checks
- `cargo fmt` - Format code
- `target/debug/graphql validate` - Run validation CLI
- `RUST_LOG=debug target/debug/graphql-lsp` - Run LSP with debug logging
- `cd editors/vscode && npm run format` - Format VSCode extension code
- `cd editors/vscode && npm run format:check` - Check VSCode extension formatting
- `cd editors/vscode && npm run lint` - Lint VSCode extension
- `cd editors/vscode && npm run compile` - Build VSCode extension

## Linting Architecture

The linting system is implemented in the `graphql-linter` crate, which is used by both the LSP and CLI.

### Separation of Concerns

- **graphql-project**: Provides core types (Diagnostic, SchemaIndex, DocumentIndex) and project management. No linting logic.
- **graphql-linter**: Implements all linting rules (document-level and project-wide). Depends on graphql-project for types.
- **graphql-lsp** and **graphql-cli**: Use graphql-linter directly for all linting needs.

### Linting Contexts

The linter supports four distinct contexts:

1. **Standalone Document**: Quick validation without schema (e.g., naming conventions)
2. **Document Against Schema**: Real-time feedback (e.g., `deprecated_field`)
3. **Standalone Schema**: Schema design validation
4. **Project-Wide**: Comprehensive analysis across all documents (e.g., `unique_names`, `unused_fields`)

### Configuration

Linting is configured via top-level `lint` in `.graphqlrc.yaml` with optional tool-specific overrides:

```yaml
# Base configuration
lint:
  recommended: error

# Tool-specific overrides
extensions:
  lsp:
    lint:
      rules:
        unused_fields: off  # Expensive, keep off for LSP
  cli:
    lint:
      rules:
        unused_fields: error  # Enable in CLI/CI
```

### Current Rules

- **deprecated_field** (DocumentSchemaRule): Warns when using @deprecated fields
- **unique_names** (ProjectRule): Ensures operation/fragment names are unique
- **unused_fields** (ProjectRule): Detects schema fields never used (opt-in, expensive)

### Performance Considerations

- **LSP**: Only runs fast document-level lints in real-time. Project-wide lints are opt-in only.
- **CLI**: Runs all enabled lints including expensive project-wide analysis.

See [graphql-linter/README.md](../crates/graphql-linter/README.md) for detailed documentation.

## Schema Loading and Introspection

The project supports loading GraphQL schemas from multiple sources:

### Local File Sources

- Single file: `schema: schema.graphql`
- Multiple files: `schema: ["schema.graphql", "extensions.graphql"]`
- Glob patterns: `schema: "schema/**/*.graphql"`

### Remote URL Sources

Schemas can be loaded from remote GraphQL endpoints via introspection:

```yaml
schema: https://api.example.com/graphql
```

When a URL is detected in the schema configuration:
1. **graphql-config** detects the URL using `has_remote_schema()`
2. **graphql-project**'s `SchemaLoader::load_remote()` is called
3. **graphql-introspect** executes the standard introspection query
4. The introspection JSON response is converted to SDL
5. The SDL is used for validation and language features

### graphql-introspect Crate

Located at `crates/graphql-introspect/`, this crate provides:

- **Introspection Query Execution**: Standard GraphQL introspection with 7 levels of type nesting
- **Type-Safe Deserialization**: Complete type definitions for introspection responses
- **SDL Conversion**: Clean, readable SDL generation that:
  - Filters built-in scalars (Int, Float, String, Boolean, ID)
  - Filters introspection types (types starting with `__`)
  - Filters built-in directives (@skip, @include, @deprecated, @specifiedBy)
  - Preserves descriptions, deprecation info, and custom directives
  - Proper indentation and GraphQL syntax

**Main API:**
- `introspect_url_to_sdl(url)` - One-step convenience function
- `execute_introspection(url)` - Execute query and get JSON response
- `introspection_to_sdl(response)` - Convert JSON to SDL

**Error Handling:**
- Network errors (connection failures, timeouts)
- HTTP errors (non-2xx status codes)
- Parse errors (invalid JSON)
- Invalid responses (malformed introspection data)

See [graphql-introspect/README.md](../crates/graphql-introspect/README.md) for detailed documentation.

## Logging and Tracing Strategy

### Framework
- Uses `tracing` crate for structured logging and instrumentation
- Uses `tracing-subscriber` with env-filter for log level control
- Outputs to stderr (LSP protocol uses stdout for JSON-RPC)
- ANSI colors disabled for LSP compatibility
- Optional OpenTelemetry integration for distributed tracing and performance analysis

### Log Levels
- **ERROR**: Critical failures (schema load errors, document processing failures)
- **WARN**: Non-fatal issues (missing config, no project found, stale data)
- **INFO**: High-level operations (server lifecycle, document operations, validation completion)
- **DEBUG**: Detailed operations (cache hits, timing measurements, internal state)
- **TRACE**: Reserved for deep debugging (not currently used)

### Configuration
- Set `RUST_LOG` environment variable to control log levels
- Default: `info` if not specified
- Examples:
  - `RUST_LOG=debug` - Enable debug logging
  - `RUST_LOG=graphql_lsp=debug,graphql_project=info` - Module-specific levels
  - `RUST_LOG=off` - Disable logging

### Guidelines
- Log user-facing operations at INFO (document open/save, validation start/complete)
- Log performance metrics with timing at DEBUG level
- Include context in log messages (file paths, project names, positions)
- Log errors immediately when they occur, before propagating
- Use structured fields for searchable data: `tracing::info!(uri = ?doc_uri, "message")`
- Keep log messages concise but informative
- Avoid logging sensitive data (API keys, credentials)
- Log at entry/exit of complex operations for traceability

### OpenTelemetry Integration

The LSP supports OpenTelemetry tracing for performance analysis and visualization of hot spots.

#### Building with OpenTelemetry Support

Build the LSP with the `otel` feature flag:

```bash
cargo build --features otel
# or for release
cargo build --release --features otel
```

#### Running with OpenTelemetry

Set the `OTEL_TRACES_ENABLED` environment variable to enable OpenTelemetry tracing:

```bash
# Start Jaeger for trace collection and visualization
docker run -d --name jaeger \
  -p 4317:4317 \
  -p 16686:16686 \
  jaegertracing/all-in-one:latest

# Run the LSP with OpenTelemetry enabled
OTEL_TRACES_ENABLED=1 ./target/debug/graphql-lsp

# Optional: Customize the OTLP endpoint (defaults to http://localhost:4317)
OTEL_TRACES_ENABLED=1 OTEL_EXPORTER_OTLP_ENDPOINT=http://localhost:4317 ./target/debug/graphql-lsp
```

#### Viewing Traces

1. Open your browser to [http://localhost:16686](http://localhost:16686)
2. Select "graphql-lsp" from the Service dropdown
3. Click "Find Traces" to view collected traces
4. Click on individual traces to see:
   - Span timings and durations
   - Call hierarchies and dependencies
   - Performance hot spots
   - Flame graphs showing where time is spent

#### Using with VSCode

To enable OpenTelemetry tracing in VSCode:

1. Ensure the LSP binary is built with `--features otel`
2. Set environment variables in VSCode settings:

```json
{
  "graphql.server.env": {
    "OTEL_TRACES_ENABLED": "1",
    "OTEL_EXPORTER_OTLP_ENDPOINT": "http://localhost:4317",
    "RUST_LOG": "debug"
  }
}
```

3. Restart VSCode or reload the window
4. Use the LSP normally while traces are collected
5. View traces in Jaeger UI

#### Performance Impact

- OpenTelemetry adds minimal overhead when enabled (~1-2% CPU)
- Traces are batched and sent asynchronously to avoid blocking LSP operations
- Can be disabled at runtime by unsetting `OTEL_TRACES_ENABLED`
- No impact when binary is built without the `otel` feature

# Instructions for Claude

- Please read and understand the contents of this file before assisting with any questions related to the GraphQL LSP project.
- Suggest updates to this file as the project evolves to keep it current and useful.
- Default to creating a new branch, committing changes, and opening a pull request for any modifications suggested.
- Don't add needless comments in source code; code should describe itself. Use comments to call out things that are subtle, confusing, or surprising.
- After finishing making changes, make sure the debug binary is built and the editor extensions are rebuilt if necessary to enable human testing.
- Put user reported bugs in .claude/notes/BUGS.md
- When starting work in a new git worktree, copy over the .claude/ directory from the main worktree to include notes and local settings.
